---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ceph-bridge
  namespace: openstack
---
# Read-only in rook-ceph for the two objects we need
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: ceph-bridge-rook-reader
  namespace: rook-ceph
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    resourceNames: ["rook-ceph-config","rook-ceph-admin-keyring"]
    verbs: ["get","list","watch"]
  - apiGroups: [""]
    resources: ["configmaps"]
    resourceNames: ["rook-ceph-config"]
    verbs: ["get","list","watch"]
---
# Writer in openstack for the targets Nova expects
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: ceph-bridge-openstack-writer
  namespace: openstack
rules:
  - apiGroups: [""]
    resources: ["configmaps"]
    resourceNames: ["ceph-etc"]
    verbs: ["get","create","update","patch"]
  - apiGroups: [""]
    resources: ["secrets"]
    resourceNames: ["pvc-ceph-client-key"]
    verbs: ["get","create","update","patch"]
---
# Bind reader role (in rook-ceph) to SA in openstack
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ceph-bridge-rook-reader-binding
  namespace: rook-ceph
subjects:
  - kind: ServiceAccount
    name: ceph-bridge
    namespace: openstack
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: ceph-bridge-rook-reader
---
# Bind writer role (in openstack) to SA in openstack
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ceph-bridge-openstack-writer-binding
  namespace: openstack
subjects:
  - kind: ServiceAccount
    name: ceph-bridge
    namespace: openstack
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: ceph-bridge-openstack-writer
---
apiVersion: batch/v1
kind: Job
metadata:
  name: ceph-bridge-presync
  namespace: openstack
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
spec:
  backoffLimit: 3
  template:
    spec:
      restartPolicy: Never
      serviceAccountName: ceph-bridge
      containers:
        - name: kubectl
          image: docker.io/bitnami/kubectl:latest
          imagePullPolicy: IfNotPresent
          command: ["/bin/sh","-c"]
          args:
            - |
              set -euo pipefail

              get_ceph_conf() {
                # 1) Secret/rook-ceph-config.ceph.conf (base64)
                if kubectl -n rook-ceph get secret rook-ceph-config >/dev/null 2>&1; then
                  CEPh_B64=$(kubectl -n rook-ceph get secret rook-ceph-config -o jsonpath='{.data.ceph\.conf}' || true)
                  if [ -n "${CEPh_B64}" ]; then
                    printf "%s" "${CEPh_B64}" | base64 -d > /work/ceph.conf
                    return 0
                  fi
                fi
                # 2) ConfigMap/rook-ceph-config.ceph.conf (plain)
                if kubectl -n rook-ceph get configmap rook-ceph-config >/dev/null 2>&1; then
                  if kubectl -n rook-ceph get configmap rook-ceph-config -o jsonpath='{.data.ceph\.conf}' >/work/ceph.conf 2>/dev/null; then
                    [ -s /work/ceph.conf ] && return 0
                  fi
                  # 3) ConfigMap/rook-ceph-config.config (older templates)
                  if kubectl -n rook-ceph get configmap rook-ceph-config -o jsonpath='{.data.config}' >/work/ceph.conf 2>/dev/null; then
                    [ -s /work/ceph.conf ] && return 0
                  fi
                fi
                return 1
              }

              echo "[1/3] Fetching ceph.conf"
              if ! get_ceph_conf; then
                echo "ERROR: could not find ceph.conf in rook-ceph/rook-ceph-config (Secret or ConfigMap)"
                echo "DEBUG: available keys on secret/configmap (if present):"
                kubectl -n rook-ceph get secret rook-ceph-config -o jsonpath='{.data}' 2>/dev/null || true; echo
                kubectl -n rook-ceph get configmap rook-ceph-config -o jsonpath='{.data}' 2>/dev/null || true; echo
                exit 1
              fi

              echo "[2/3] Upsert ConfigMap openstack/ceph-etc"
              kubectl -n openstack create configmap ceph-etc \
                --from-file=ceph.conf=/work/ceph.conf \
                --dry-run=client -o yaml | kubectl apply -f -

              echo "[3/3] Extract admin key and upsert Secret openstack/pvc-ceph-client-key"
              KEY_B64=$(kubectl -n rook-ceph get secret rook-ceph-admin-keyring -o jsonpath='{.data.keyring}')
              KEY_RAW=$(printf "%s" "$KEY_B64" | base64 -d | sed -n 's/^[[:space:]]*key[[:space:]]*=[[:space:]]*\(.*\)$/\1/p' | tr -d '\r')
              if [ -z "${KEY_RAW}" ]; then
                echo "ERROR: failed to parse admin key from rook-ceph-admin-keyring"
                exit 1
              fi
              kubectl -n openstack create secret generic pvc-ceph-client-key \
                --from-literal=key="$KEY_RAW" \
                --dry-run=client -o yaml | kubectl apply -f -

              echo "Done." 
          volumeMounts:
            - name: work
              mountPath: /work
      volumes:
        - name: work
          emptyDir: {}
