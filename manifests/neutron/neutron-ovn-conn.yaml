apiVersion: v1
kind: ServiceAccount
metadata:
  name: neutron-ovn-confgen
  namespace: openstack
  labels:
    app.kubernetes.io/name: neutron-ovn-confgen
    application: neutron
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: neutron-ovn-confgen
  namespace: openstack
rules:
  - apiGroups: [""]
    resources: ["services","endpoints","endpointslices","configmaps"]
    verbs: ["get","list","watch","create","update","patch","delete"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: neutron-ovn-confgen
  namespace: openstack
subjects:
  - kind: ServiceAccount
    name: neutron-ovn-confgen
    namespace: openstack
roleRef:
  kind: Role
  name: neutron-ovn-confgen
  apiGroup: rbac.authorization.k8s.io
---
# Empty CM object so workloads can mount it immediately; the Job will replace it with data
apiVersion: v1
kind: ConfigMap
metadata:
  name: neutron-ovn-conn
  namespace: openstack
  labels:
    app.kubernetes.io/name: neutron-ovn-confgen
    application: neutron
data: {}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: neutron-ovn-confgen
  namespace: openstack
  labels:
    app.kubernetes.io/name: neutron-ovn-confgen
    application: neutron
  annotations:
    # Make sure this runs BEFORE the chartâ€™s neutron-server (wave ~40) and every sync
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
    argocd.argoproj.io/sync-wave: "35"
spec:
  backoffLimit: 3
  template:
    metadata:
      labels:
        app.kubernetes.io/name: neutron-ovn-confgen
        application: neutron
    spec:
      serviceAccountName: neutron-ovn-confgen
      restartPolicy: OnFailure
      containers:
        - name: confgen
          image: bitnami/kubectl:1.30
          command: ["/bin/sh","-c"]
          args:
            - |
              set -euo pipefail
              ns="openstack"
              nb_svc="ovn-ovsdb-nb"
              sb_svc="ovn-ovsdb-sb"

              # ClusterIP (SingleStack is fine)
              nb_ip="$(kubectl -n "$ns" get svc "$nb_svc" -o jsonpath='{.spec.clusterIP}')"
              sb_ip="$(kubectl -n "$ns" get svc "$sb_svc" -o jsonpath='{.spec.clusterIP}')"

              # Choose TLS port if present, else TCP
              pick_port() {
                svc="$1"; tls="$2"; tcp="$3"
                ports="$(kubectl -n "$ns" get endpoints "$svc" -o jsonpath='{range .subsets[*].ports[*]}{.port}{"\n"}{end}' || true)"
                if echo "$ports" | grep -qx "$tls"; then echo "$tls ssl"; elif echo "$ports" | grep -qx "$tcp"; then echo "$tcp tcp"; else echo "$tcp tcp"; fi
              }

              read nb_port nb_proto <<EOF
              $(pick_port "$nb_svc" 6643 6641)
              EOF
              read sb_port sb_proto <<EOF
              $(pick_port "$sb_svc" 6644 6642)
              EOF

              ovn_nb="${nb_proto}:${nb_ip}:${nb_port}"
              ovn_sb="${sb_proto}:${sb_ip}:${sb_port}"

              cat > /tmp/10-ovn-connections.ini <<EOF
              [ovn]
              ovn_nb_connection = ${ovn_nb}
              ovn_sb_connection = ${ovn_sb}
              neutron_sync_mode = repair
              EOF

              # Replace the CM atomically with file data
              kubectl -n "$ns" create configmap neutron-ovn-conn \
                --from-file=10-ovn-connections.ini=/tmp/10-ovn-connections.ini \
                --dry-run=client -o yaml | kubectl apply -f -

              echo "Generated:"
              cat /tmp/10-ovn-connections.ini

